#include <arpa/inet.h>
#include <sys/socket.h>
#include <netdb.h>
#include <net/if.h>
#include <ifaddrs.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include <cerrno>
#include <vector>
#include <fmt/core.h>
#include <boost/asio/ip/address_v4.hpp>
#include <libtun/Exception.h>

int main() {
  auto ifs = getInterfaces();
  for (auto i : ifs) {
    fmt::print("{}: {}\n", i.name, i.address.to_string());
  }
    // struct ifaddrs *ifaddr, *ifa;
    // int family, s;
    // char host[NI_MAXHOST];



    /* Walk through linked list, maintaining head pointer so we
        can free list later */

    // for (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {
    //     if (ifa->ifa_addr == NULL)
    //         continue;

    //     family = ifa->ifa_addr->sa_family;

    //     /* Display interface name and family (including symbolic
    //         form of the latter for the common families) */

    //     printf("%-8s %s (%d)\n",
    //             ifa->ifa_name,
    //             (family == AF_INET) ? "AF_INET" :
    //             (family == AF_INET6) ? "AF_INET6" : "???",
    //             family);

        /* For an AF_INET* interface address, display the address */

        // if (family == AF_INET || family == AF_INET6) {
            // s = getnameinfo(ifa->ifa_addr,
            //         (family == AF_INET) ? sizeof(struct sockaddr_in) :
            //                                 sizeof(struct sockaddr_in6),
            //         host, NI_MAXHOST,
            //         NULL, 0, NI_NUMERICHOST);
            // if (s != 0) {
            //     printf("getnameinfo() failed: %s\n", gai_strerror(s));
            //     exit(EXIT_FAILURE);
            // }

            // printf("\t\taddress: <%s>\n", host);

    //    } else if (family == AF_PACKET && ifa->ifa_data != NULL) {
    //        struct rtnl_link_stats *stats = ifa->ifa_data;

    //        printf("\t\ttx_packets = %10u; rx_packets = %10u\n"
    //               "\t\ttx_bytes   = %10u; rx_bytes   = %10u\n",
    //               stats->tx_packets, stats->rx_packets,
    //               stats->tx_bytes, stats->rx_bytes);
    //     }
    // }

    // exit(EXIT_SUCCESS);
}



//     // int fd = socket (PF_INET, SOCK_RAW, 255);
//     // int one = 1;
//     // const int *val = &one;
//     // setsockopt(fd, IPPROTO_IP, IP_HDRINCL, val, sizeof(one));

//     // int idx = if_nametoindex("en0");
//     // setsockopt(fd, IPPROTO_IP, IP_BOUND_IF, &idx, sizeof(idx));

//     // if(setsockopt(fd, SOL_SOCKET, SO_BINDTODEVICE, ifname, 3) < 0) {
//     //   perror("setsockopt() error");
//     //   exit(2);
//     // }
//   //   char buffer[8192]; /* single packets are usually not bigger than 8192 bytes */
//   //   while (1) {
//   //     int len = recvfrom(fd , buffer , 8192 , 0 , NULL, NULL);

//   //     // int len = read(fd, buffer, 8192);
//   //     ipdump.dump(buffer, len);
//   //     ipdump.dump("PACKET_END", 10);
//   //     trace << len << "bytes received.";
//   //   }


//   return 1;
// }